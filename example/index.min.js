var stream = (function (exports) {
	'use strict';

	function getStream(constraints) {
	  return navigator.mediaDevices.getUserMedia(constraints);
	}
	var MediaDevice = {
	  getStream
	};

	function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
	  try {
	    var info = gen[key](arg);
	    var value = info.value;
	  } catch (error) {
	    reject(error);
	    return;
	  }

	  if (info.done) {
	    resolve(value);
	  } else {
	    Promise.resolve(value).then(_next, _throw);
	  }
	}

	function _asyncToGenerator(fn) {
	  return function () {
	    var self = this,
	        args = arguments;
	    return new Promise(function (resolve, reject) {
	      var gen = fn.apply(self, args);

	      function _next(value) {
	        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
	      }

	      function _throw(err) {
	        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
	      }

	      _next(undefined);
	    });
	  };
	}

	class AbstractStreamManager {
	  setStreamKeys(streamKeys) {
	    this.streamKeys = streamKeys;
	  }

	  setStartFunctions(startFns) {
	    this.startFns = startFns;
	  }

	  constructor() {
	    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    this.mediaStreams = {};
	    this.subStreams = {};
	    this.streamKeys = data.streamKeys || {};
	    this.startFns = data.startFns || {};
	    this.cleanupBeforeStart = data.cleanupBeforeStart || false;
	    this.cleanupAfterStop = data.cleanupAfterStop || false;
	  }

	  isAvailable(controlId) {
	    return !!this.subStreams[controlId];
	  }

	  start(controlId, args) {
	    var _this = this;

	    return _asyncToGenerator(function* () {
	      if (controlId in _this.subStreams) return;

	      if (_this.cleanupBeforeStart) {
	        _this.cleanup();
	      }

	      try {
	        _this.subStreams[controlId] = 'pending';
	        var params = _this.startFns[controlId];
	        var fn = params.fn;
	        args = args || params.args;
	        var stream = yield fn.apply(null, [args]);
	        _this.subStreams[controlId] = stream;
	      } catch (err) {
	        delete _this.subStreams[controlId];
	        throw err;
	      }
	    })();
	  }

	  stop(controlId) {
	    if (controlId in this.subStreams) {
	      try {
	        var activeStream = this.subStreams[controlId];
	        activeStream.getTracks().forEach(track => {
	          track.stop();
	          activeStream.removeTrack(track);
	        });
	        delete this.subStreams[controlId];
	      } catch (err) {
	        if (this.cleanupAfterStop) {
	          this.cleanup();
	        }
	      }
	    }
	  }

	  enable(controlId) {
	    if (controlId in this.subStreams) {
	      try {
	        var activeStream = this.subStreams[controlId];
	        activeStream.getTracks().forEach(track => {
	          track.enabled = true;
	        });
	      } catch (err) {
	        console.log(err);
	      }
	    }
	  }

	  isEnabled(controlId) {
	    if (controlId in this.subStreams) {
	      try {
	        var activeStream = this.subStreams[controlId];
	        var isAllEnabled = true;
	        activeStream.getTracks().forEach(track => {
	          isAllEnabled &= track.enabled;
	        });
	        return isAllEnabled;
	      } catch (err) {
	        console.log(err);
	        return false;
	      }
	    } else {
	      return false;
	    }
	  }

	  disable(controlId) {
	    if (controlId in this.subStreams) {
	      try {
	        var activeStream = this.subStreams[controlId];
	        activeStream.getTracks().forEach(track => {
	          track.enabled = false;
	        });
	      } catch (err) {
	        console.log(err);
	      }
	    }
	  }

	  isDisabled(controlId) {
	    if (controlId in this.subStreams) {
	      try {
	        var activeStream = this.subStreams[controlId];
	        var isAllDisabled = true;
	        activeStream.getTracks().forEach(track => {
	          isAllDisabled &= !track.enabled;
	        });
	        return isAllDisabled;
	      } catch (err) {
	        console.log(err);
	        return false;
	      }
	    } else {
	      return false;
	    }
	  }

	  cleanup() {
	    var _this2 = this;

	    var _loop = function _loop(key) {
	      var mediaStream = _this2.mediaStreams[key];
	      mediaStream.getTracks().forEach(track => {
	        if (track.readyState === 'ended') {
	          mediaStream.removeTrack(track);
	        }
	      });

	      if (!mediaStream.active || mediaStream.getTracks().length === 0) {
	        delete _this2.mediaStreams[key];
	      }
	    };

	    for (var key in this.mediaStreams) {
	      _loop(key);
	    }
	  }

	  composeAs(keys, mediaStreamKey) {
	    var activeStream = this.mediaStreams[mediaStreamKey];

	    if (!activeStream) {
	      activeStream = new MediaStream();
	      this.mediaStreams[mediaStreamKey] = activeStream;
	    }

	    for (var i = 0; i < keys.length; i++) {
	      var key = keys[i];

	      if (key in this.subStreams) {
	        var srcStream = this.subStreams[key];
	        srcStream.getTracks().forEach(track => activeStream.addTrack(track));
	      }
	    }

	    return activeStream;
	  }

	}

	class StreamManager extends AbstractStreamManager {
	  get isDisplayAvailable() {
	    return this.isAvailable(this.streamKeys.display);
	  }

	  get isCameraAvailable() {
	    return this.isAvailable(this.streamKeys.camera);
	  }

	  get isMicrophoneAvailable() {
	    return this.isAvailable(this.streamKeys.microphone);
	  }

	}

	class CustomElement {
	  constructor(element) {
	    this.target = element;
	  }

	  css(styles) {
	    var {
	      target
	    } = this;

	    try {
	      Object.assign(target.style, styles);
	    } catch (err) {
	      console.trace();
	    }
	  }

	  on(name, callback) {
	    var {
	      target
	    } = this;

	    try {
	      target.addEventListener(name, callback);
	    } catch (err) {
	      console.trace();
	    }
	  }

	  off(name, callback) {
	    var {
	      target
	    } = this;

	    try {
	      target.removeEventListener(name, callback);
	    } catch (err) {
	      console.trace();
	    }
	  }

	}

	var $ = target => {
	  if (target instanceof CustomElement) {
	    return target;
	  } else {
	    return new CustomElement(target);
	  }
	};

	/*
	 * @category: static function
	 * @description: Create event types from string array
	 * @name: createEventTypes
	 * @param: {Array} eventNames - The keys of event
	 * @returns: {Object} - The Event types object
	 * @example:
	 * const Events = createEventTypes([
	 *   'AddObject',
	 *   'RemoveObject',
	 * ]);
	 */

	var createEventTypes = (eventNames, prefix) => {
	  prefix = prefix || '';
	  return eventNames.reduce((m, i, j) => {
	    m[i] = prefix + j.toString(16);
	    return m;
	  }, {});
	};
	/*
	 * @category: static function
	 * @name: registerEvent
	 * @description: Register event for element
	 * @param: {Element} elem - Element
	 * @param: {string} type - The event type
	 * @param: {Function} fn - The event handler
	 * @returns: {Function} - The function which is used to unregister the event handler
	 */

	var registerEvent = (elem, type, fn) => {
	  if (type && fn) {
	    return elem.on(type, fn);
	  }
	};
	/*
	 * @category: static function
	 * @name: registerEvents
	 * @description: Register events for element
	 * @param: {Element} elem - Element
	 * @param: {Object} events - The key-value event handler object
	 * @returns: {Function} - The function which is used to unregister the event handler
	 */

	var registerEvents = (elem, events) => {
	  var unbindFns = [];

	  for (var key in events) {
	    var handler = events[key];
	    var unbindFn = registerEvent(elem, key, handler);
	    unbindFn && unbindFns.push(unbindFn);
	  }

	  return () => {
	    unbindFns.forEach(fn => fn());
	  };
	};
	/*
	 * @category: static function
	 * @name: stopEventChain
	 * @description: Stop the event handler & bubbling
	 * @param: {Event} event - Event
	 * @returns: No return value
	 */

	var stopEventChain = event => {
	  try {
	    if (event.defaultPrevented) {
	      event.preventDefault();
	    }

	    event.stopPropagation();
	  } catch (err) {}
	};
	/*
	 * @category: static function
	 * @name: registerElementEvents
	 * @description: Register onClick/onDoubleClick/onLongClick event for element
	 * @param: {Element} elem - Element
	 * @param: {Object} events - The key-value event handler object
	 * @returns: {Function} - The function which is used to unregister the event handler
	 */

	var registerElementEvents = (elem, events) => {
	  var jElem = $(elem);

	  var Noop = () => {};

	  var EmptyHandlers = {
	    onDown: Noop,
	    onUp: Noop
	  };
	  var isHandled = false;
	  var activeTimers = {};
	  var downTimer;
	  var lastDownTimestamp;
	  var isMouseEntered;

	  function containsTimer(id) {
	    return id in activeTimers;
	  }

	  function startActiveTimer(id) {
	    if (!containsTimer(id)) {
	      activeTimers[id] = window.setTimeout(() => {
	        clearActiveTimer(id);
	      }, 100);
	    }
	  }

	  function clearActiveTimer(id) {
	    if (containsTimer(id)) {
	      window.clearTimeout(activeTimers[id]);
	      delete activeTimers[id];
	    }
	  }

	  var handleClick = event => {
	    if (!isHandled) {
	      stopEventChain(event);
	      events.onClick && events.onClick(event);
	    }

	    isHandled = true;
	  };

	  var handleDoubleClick = () => {
	    if (!isHandled) {
	      events.onDoubleClick && events.onDoubleClick.handler();
	    }

	    isHandled = true;
	  };

	  var handleLongClick = () => {
	    if (!isHandled && isMouseEntered) {
	      events.onLongClick && events.onLongClick.handler();
	    }

	    isHandled = true;
	  };

	  var longClickHandlers = events.onLongClick ? {
	    onDown: () => {
	      clearDownTimer();
	      downTimer = setTimeout(() => {
	        downTimer = undefined;
	        handleLongClick();
	      }, events.onLongClick.threshold);
	    },
	    onUp: () => {
	      clearDownTimer();
	    }
	  } : EmptyHandlers;

	  var getMousePosition = evt => {
	    return {
	      x: evt.clientX,
	      y: evt.clientY,
	      screenX: evt.screenX,
	      screenY: evt.screenY
	    };
	  };

	  var getTouchPosition = touchObject => {
	    return {
	      x: touchObject.clientX,
	      y: touchObject.clientY,
	      screenX: touchObject.screenX,
	      screenY: touchObject.screenY
	    };
	  };

	  var clickContext = {};

	  var isPositionInThreshold = (pos1, pos2) => {
	    return Math.abs(pos1.x - pos2.x) < 10 && Math.abs(pos1.y - pos2.y) < 10;
	  };

	  var clickHandlers = events.onDoubleClick ? {
	    onDown: function onDown() {
	      var {
	        position
	      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      clickContext.startPos = position;

	      if (lastDownTimestamp && Date.now() - lastDownTimestamp <= events.onDoubleClick.threshold) {
	        handleDoubleClick();
	        lastDownTimestamp = undefined;
	      } else {
	        lastDownTimestamp = Date.now();
	      }
	    },
	    onUp: function onUp() {
	      var {
	        position,
	        event
	      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	      if (isPositionInThreshold(clickContext.startPos, position)) {
	        handleClick(event);
	      }
	    }
	  } : {
	    onDown: function onDown() {
	      var {
	        position
	      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      clickContext.startPos = position;
	    },
	    onUp: function onUp() {
	      var {
	        position,
	        event
	      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	      if (isPositionInThreshold(clickContext.startPos, position)) {
	        handleClick(event);
	      }
	    }
	  };

	  var clearDownTimer = () => {
	    if (downTimer) {
	      window.clearTimeout(downTimer);
	      downTimer = undefined;
	    }
	  };
	  /* Enter/Leave events */


	  var onMouseOutHandler = () => {
	    isMouseEntered = false;
	  };

	  var onMouseEnterHandler = () => {
	    isMouseEntered = true;
	  };
	  /**/


	  var onMouseDownHandler = event => {
	    stopEventChain(event);
	    if (containsTimer('t')) return;
	    isHandled = false;
	    isMouseEntered = true;
	    longClickHandlers.onDown();
	    clickHandlers.onDown({
	      position: getMousePosition(event),
	      event
	    });
	    jElem.on('mouseup', onMouseUpHandler);
	    jElem.on('mouseout', onMouseOutHandler);
	    jElem.on('mouseenter', onMouseEnterHandler);
	    return true;
	  };

	  var onTouchStartHandler = event => {
	    if (containsTimer('m')) return;
	    isHandled = false;
	    longClickHandlers.onDown();
	    clickHandlers.onDown({
	      position: getTouchPosition(event.changedTouches[event.changedTouches.length - 1]),
	      event
	    });
	    jElem.on('touchend', onTouchEndHandler);
	    return true;
	  };
	  /**/


	  var onMouseUpHandler = event => {
	    stopEventChain(event);
	    jElem.off('mouseup', onMouseUpHandler);
	    jElem.off('mouseout', onMouseOutHandler);
	    jElem.off('mouseenter', onMouseEnterHandler);
	    longClickHandlers.onUp();
	    clickHandlers.onUp({
	      position: getMousePosition(event),
	      event
	    });
	    startActiveTimer('m');
	    return true;
	  };

	  var onTouchEndHandler = event => {
	    jElem.off('touchend', onTouchEndHandler);
	    longClickHandlers.onUp();
	    clickHandlers.onUp({
	      position: getTouchPosition(event.changedTouches[event.changedTouches.length - 1]),
	      event
	    });
	    startActiveTimer('t');
	    return true;
	  };

	  jElem.on('mousedown', onMouseDownHandler);
	  jElem.on('touchstart', onTouchStartHandler);
	  return function () {
	    jElem.off('mousedown', onMouseDownHandler);
	    jElem.off('touchstart', onTouchStartHandler);
	    jElem.off('mouseup', onMouseUpHandler);
	    jElem.off('mouseout', onMouseOutHandler);
	    jElem.off('mouseenter', onMouseEnterHandler);
	    jElem.off('touchend', onTouchEndHandler);
	  };
	};

	var EventUtils$ = /*#__PURE__*/Object.freeze({
	  __proto__: null,
	  createEventTypes: createEventTypes,
	  registerEvent: registerEvent,
	  registerEvents: registerEvents,
	  stopEventChain: stopEventChain,
	  registerElementEvents: registerElementEvents
	});

	var EventUtils = EventUtils$;

	var Events = EventUtils.createEventTypes(['Detect', 'Ignore', 'ThresholdChanged', 'StreamChanged', 'Start', 'Stop', 'Process']);

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var Core = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, '__esModule', { value: true });

	function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
	  try {
	    var info = gen[key](arg);
	    var value = info.value;
	  } catch (error) {
	    reject(error);
	    return;
	  }

	  if (info.done) {
	    resolve(value);
	  } else {
	    Promise.resolve(value).then(_next, _throw);
	  }
	}

	function _asyncToGenerator(fn) {
	  return function () {
	    var self = this,
	        args = arguments;
	    return new Promise(function (resolve, reject) {
	      var gen = fn.apply(self, args);

	      function _next(value) {
	        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
	      }

	      function _throw(err) {
	        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
	      }

	      _next(undefined);
	    });
	  };
	}

	var triggerEventsAsync = /*#__PURE__*/function () {
	  var _ref2 = _asyncToGenerator(function* (_ref) {
	    var {
	      target,
	      eventArray,
	      args
	    } = _ref;

	    for (var i in eventArray) {
	      var fn = eventArray[i];
	      yield fn.apply(target, args);
	    }
	  });

	  return function triggerEventsAsync(_x) {
	    return _ref2.apply(this, arguments);
	  };
	}();

	class EventModel {
	  constructor(data) {
	    this._events = {};
	    Object.assign(this, data);
	  }

	  _on(name, fn) {
	    var eventArray = this._events[name];

	    if (!eventArray) {
	      eventArray = this._events[name] = [];
	    }

	    eventArray.push(fn);
	    return () => {
	      this.off(name, fn);
	    };
	  }

	  on(arg1, argFn) {
	    var typeofArg1 = typeof arg1;

	    switch (typeofArg1) {
	      case 'object':
	        var unbindFns = [];

	        for (var name in arg1) {
	          var fn = arg1[name];
	          unbindFns.push(this._on(name, fn));
	        }

	        return () => {
	          unbindFns.forEach(unbindFn => {
	            unbindFn();
	          });
	        };

	      case 'string':
	        return this._on(arg1, argFn);

	      default:
	        throw new Error('Invalid arguments!');
	    }
	  }

	  off(name, fn) {
	    var eventArray = this._events[name];

	    if (eventArray) {
	      var index = eventArray.indexOf(fn);

	      if (index >= 0) {
	        eventArray.splice(index, 1);
	      }
	    }
	  }

	  trigger(name, args) {
	    var eventArray = this._events[name];

	    if (eventArray) {
	      var target = this;
	      triggerEventsAsync({
	        target,
	        eventArray,
	        args
	      });
	    }
	  }

	  unbindEvent(name) {
	    var fn = this[name];

	    if (fn) {
	      fn();
	      delete this[name];
	    }
	  }

	}

	class IdGenerator {
	  constructor(prefix) {
	    this.serialNumber = 0;
	    this.prefix = typeof prefix === 'string' ? prefix : 'o';
	  }

	  setIdPrefix(prefix) {
	    this.prefix = prefix;
	  }

	  genId() {
	    var newId = this.serialNumber;
	    this.serialNumber++;
	    return this.prefix + newId.toString(16);
	  }

	  reset() {
	    this.serialNumber = 0;
	  }

	}

	class NameGenerator {
	  constructor(prefix) {
	    this.serialNumber = 1;
	    this.prefix = typeof prefix === 'string' ? prefix : 'Name';
	  }

	  setPrefix(prefix) {
	    this.prefix = prefix;
	  }

	  genName() {
	    var {
	      serialNumber,
	      prefix
	    } = this;
	    var newName = "".concat(prefix).concat(serialNumber);
	    this.serialNumber++;
	    return newName;
	  }

	}

	/*
	 * @category: static function
	 * @description: The for-each function for Array/Object instance
	 * @name: forEach
	 * @param: {Object} objects - The object
	 * @param: {Function} callback - The iteration function
	 * @returns: No return value
	 * @example:
	 * forEach({
	 *   a: '22',
	 *   b: '33'
	 * }, (value, key, index) => {
	 *   // return true to interrupt the for-loop. 
	 * });
	 */

	var forEach = (objects, callback) => {
	  if (objects === null || typeof objects === 'undefined') return;

	  if (Array.isArray(objects) || objects instanceof NodeList) {
	    var length = objects.length;

	    if (length) {
	      for (var i = 0; i < length; i++) {
	        if (callback(objects[i], i, i)) {
	          break;
	        }
	      }
	    }
	  } else {
	    var index = 0;

	    for (var _i2 in objects) {
	      if (callback(objects[_i2], _i2, index)) {
	        break;
	      }

	      index++;
	    }
	  }
	};
	/*
	 * @category: static function
	 * @description: The for-each async function for Array/Object instance
	 * @name: forEachAsync
	 * @param: {Object} objects - The object
	 * @param: {Function} callback - The iteration function
	 * @returns: No return value
	 * @example:
	 * forEachAsync({
	 *   a: '22',
	 *   b: '33'
	 * }, async (value, key, index) => {
	 *   // return true to interrupt the for-loop.
	 * });
	 */

	var forEachAsync = /*#__PURE__*/function () {
	  var _ref = _asyncToGenerator(function* (objects, callback) {
	    if (objects === null || typeof objects === 'undefined') return;

	    if (Array.isArray(objects) || objects instanceof NodeList) {
	      var length = objects.length;

	      if (length) {
	        for (var i = 0; i < length; i++) {
	          if (yield callback(objects[i], i, i)) {
	            break;
	          }
	        }
	      }
	    } else {
	      var index = 0;

	      for (var _i3 in objects) {
	        if (yield callback(objects[_i3], _i3, index)) {
	          break;
	        }

	        index++;
	      }
	    }
	  });

	  return function forEachAsync(_x, _x2) {
	    return _ref.apply(this, arguments);
	  };
	}();
	/*
	 * @category: static function
	 * @description: The map function for Array/Object instance
	 * @name: map
	 * @param: {Object} objects - The object
	 * @param: {Function} callback - The iteration function
	 * @returns: {Array\<Any\>} - The object
	 * @example:
	 * map({
	 *   a: '22',
	 *   b: '33'
	 * }, (value, key, index) => {
	 *   return {
	 *     name: key,
	 *     data: value
	 * };
	 * });
	 */

	var map = (objects, callback) => {
	  var result = [];
	  forEach(objects, (value, key, index) => {
	    result.push(callback(value, key, index));
	  });
	  return result;
	};
	/*
	 * @category: static function
	 * @description: Filter objects by function
	 * @name: filter
	 * @param: {Object} objects - The object
	 * @param: {Function} filterFn - The function used to find matched object
	 * @returns: {Array\<Any\>} - The filtered array
	 * @example:
	 * filter({
	 *   name: 'foo'
	 * },{
	 *   name: 'bar'
	 * }, (object) => { return object.name === 'bar' });
	 */

	var filter = (objects, filterFn) => {
	  var result = [];
	  forEach(objects, object => {
	    if (filterFn(object)) {
	      result.push(object);
	    }
	  });
	  return result;
	};
	/*
	 * @category: static function
	 * @description: Invoke the method by target, with function name, arguments
	 * @name: delegate
	 * @param: {Object} data - The object
	 * @returns: {Any} - The return value of target[fnName]
	 * @example:
	 * const result = delegate(target, 'getNameById', [id]);
	 */

	var delegate = (target, fnName, args) => {
	  if (target) {
	    try {
	      var splittedFns = fnName.split('.');
	      var caller = target;

	      for (var i = 0; i < splittedFns.length - 1; i++) {
	        var _fn = splittedFns[i];
	        caller = caller[_fn];
	      }

	      var fn = splittedFns[splittedFns.length - 1];
	      return caller[fn].apply(caller, args);
	    } catch (err) {}
	  }
	};

	var getObjectId = object => {
	  return object.getId ? object.getId() : object.id;
	};

	class ObjectManager extends EventModel {
	  constructor(data) {
	    super(data);

	    this._clear();
	  }

	  get objects() {
	    return this._objects;
	  }

	  get length() {
	    return this._length;
	  }

	  _add(objId, object, index) {
	    if (this.canAddObject(objId, object, index)) {
	      this._objects[objId] = object;
	      this._length++;
	      this.doOnAddObject(objId, object, index);
	    } else {
	      console.log('Cannot add object', objId, object, index);
	    }
	  }

	  canAddObject(objId, object, index) {
	    var isInInObjects = this.containsId(objId);
	    return !isInInObjects;
	  }

	  doOnAddObject(objId, object, index) {}

	  doOnRemoveObject(objId) {}

	  add(object, index) {
	    var objId = getObjectId(object);

	    this._add(objId, object, index);
	  }

	  addAll(objects) {
	    forEach(objects, object => this.add(object));
	  }

	  remove(object) {
	    var objId = getObjectId(object);
	    this.removeById(objId);
	  }

	  _removeById(id) {
	    this.doOnRemoveObject(id);
	    var object = this._objects[id];
	    delete this._objects[id];
	    this._length--;
	    return object;
	  }

	  removeById(id) {
	    if (this.containsId(id)) {
	      return this._removeById(id);
	    }
	  }

	  removeByIds(ids) {
	    forEach(ids, id => {
	      this.removeById(id);
	    });
	  }

	  _clear() {
	    this._length = 0;
	    this._objects = {};
	  }

	  clear() {
	    this._clear();
	  }

	  getById(id) {
	    return this._objects[id];
	  }

	  getByIds(ids) {
	    var objects = [];
	    forEach(ids, id => {
	      var object = this.getById(id);

	      if (object) {
	        objects.push(object);
	      }
	    });
	    return objects;
	  }

	  getObjectIds() {
	    return Object.keys(this._objects);
	  }

	  containsId(id) {
	    return id in this._objects;
	  }

	  contains(object) {
	    return this.containsId(getObjectId(object));
	  }

	  update(id, data) {
	    var obj = this.getById(id);
	    if (obj) obj.update(data);
	  }

	  refresh(dataArray) {
	    this._clear();

	    forEach(dataArray, obj => {
	      var objId = obj.getId();

	      this._add(objId, obj);
	    });
	  }

	  map(callback) {
	    return map(this._objects, callback);
	  }

	  forEach(callback) {
	    return forEach(this._objects, callback);
	  }

	  forEachAsync(callback) {
	    return forEachAsync(this._objects, callback);
	  }

	  filter(byFn) {
	    return filter(this._objects, byFn);
	  }

	  forEachReversed(callback) {
	    return forEach(this._objects, callback);
	  }

	  getObjectsArray() {
	    var objects = [];
	    this.forEach(obj => {
	      objects.push(obj);
	    });
	    return objects;
	  }

	  log() {
	    this.forEach(obj => {
	      obj.log();
	    });
	  }

	  delegate(fn, args) {
	    this.forEach(obj => {
	      delegate(obj, fn, args);
	    });
	  }

	  toJson() {
	    var jsonData = {};
	    this.forEach(obj => {
	      if (!obj.isStatic && obj.toJson) {
	        jsonData[obj.getId()] = obj.toJson();
	      }
	    });
	    return jsonData;
	  } // This will call "clone" function for each object


	  cloneObjects() {
	    return map(this.objects, object => object.clone());
	  }

	  reload(objectManager) {
	    this._clear();

	    this.addAll(objectManager.objects);
	    this._length = objectManager._length;
	  }

	}

	class SortedObjectManager extends ObjectManager {
	  constructor(data) {
	    super(data);
	    this._indices = [];
	  }

	  get objectOrders() {
	    return this._indices;
	  }

	  canAddObject(objId, object, index) {
	    var isInInObjects = this.containsId(objId);
	    return !isInInObjects && (typeof index === 'undefined' || typeof index === 'number' && index >= 0 && index <= this._indices.length);
	  }

	  doOnAddObject(objId, object, index) {
	    if (typeof index === 'number') {
	      this._indices.splice(index, 0, objId);
	    } else {
	      this._indices.push(objId);
	    }
	  }

	  doOnRemoveObject(objId) {
	    var index = this._indices.indexOf(objId);

	    if (index >= 0) {
	      this._indices.splice(index, 1);
	    }
	  }

	  clear() {
	    super.clear();
	    this._indices = [];
	  }

	  removeByIndex(index) {
	    var id = this._indices[index];
	    return this.removeById(id);
	  }

	  getObjectIds() {
	    return this.objectOrders;
	  }

	  getByIndex(index) {
	    var id = this._indices[index];
	    return this._objects[id];
	  }

	  indexOf(object) {
	    var objId = getObjectId(object);
	    return this._indices.indexOf(objId);
	  }

	  setObjectIndex(object, newIndex) {
	    var objId = getObjectId(object);

	    if (this.containsId(objId) && newIndex >= 0 && newIndex < this.length) {
	      var objIndex = this._indices.indexOf(objId);

	      this._indices.splice(objIndex, 1);

	      this._indices.splice(newIndex, 0, objId);
	    }
	  }

	  forEach(callback) {
	    return forEach(this._indices, (id, key, index) => {
	      var object = this._objects[id];
	      object && callback(object, id, index);
	    });
	  }

	  forEachAsync(callback) {
	    var _this = this;

	    return forEachAsync(this._indices, /*#__PURE__*/function () {
	      var _ref = _asyncToGenerator(function* (id, key, index) {
	        var object = _this._objects[id];
	        object && (yield callback(object, id, index));
	      });

	      return function (_x, _x2, _x3) {
	        return _ref.apply(this, arguments);
	      };
	    }());
	  }

	  forEachReversed(callback) {
	    forEach([...this._indices].reverse(), (id, key, index) => {
	      var object = this._objects[id];
	      return object && callback(object, id, index);
	    });
	  }

	  map(callback) {
	    return map(this._indices, id => {
	      return callback(this._objects[id], id);
	    });
	  }

	  reload(objectManager) {
	    this._clear();

	    this.addAll(objectManager.objects);
	    this._length = objectManager._length;
	    this._indices = objectManager._indices.slice();
	  }

	}

	exports.EventModel = EventModel;
	exports.IdGenerator = IdGenerator;
	exports.NameGenerator = NameGenerator;
	exports.ObjectManager = ObjectManager;
	exports.SortedObjectManager = SortedObjectManager;
	});

	unwrapExports(Core);
	var Core_1 = Core.EventModel;
	var Core_2 = Core.IdGenerator;
	var Core_3 = Core.NameGenerator;
	var Core_4 = Core.ObjectManager;
	var Core_5 = Core.SortedObjectManager;

	class VolumeDetector extends Core_1 {
	  constructor(data) {
	    super(data);
	    this.volumeThreshold = this.volumeThreshold || 2;
	    this.isStart = false;
	    this.audioContext = null;
	    this.mediaStreamSource = null;
	    this.processor = null;
	    this.analyser = null;
	  }

	  setStream(stream) {
	    this.stream = stream;
	    this.trigger(Events.StreamChanged, [this.stream]);
	  }

	  setVolumeThreshold(volumeThreshold) {
	    this.volumeThreshold = volumeThreshold;
	    this.trigger(Events.ThresholdChanged, [this.volumeThreshold]);
	  }

	  getMicStream() {
	    var _this = this;

	    return _asyncToGenerator(function* () {
	      return _this.stream || (yield getStream({
	        audio: true
	      }));
	    })();
	  }

	  clearAudioContext() {
	    this.audioContext = null;
	    this.mediaStreamSource = null;
	    this.processor = null;
	    this.analyser = null;
	  }

	  volumeAudioProcess(event) {
	    var values = 0;

	    if (!this.analyser) {
	      return;
	    }

	    var array = new Uint8Array(this.analyser.frequencyBinCount);
	    this.analyser.getByteFrequencyData(array);
	    var length = array.length;

	    for (var i = 0; i < length; i++) {
	      values += array[i];
	    }

	    var average = values / length;

	    if (average >= this.volumeThreshold) {
	      this.trigger(Events.Detect, [average]);
	    } else {
	      this.trigger(Events.Ignore, [average]);
	    }

	    this.trigger(Events.Process, [array]);
	  }

	  startFromArrayBuffer(arrayBuffer) {
	    var _this2 = this;

	    return _asyncToGenerator(function* () {
	      if (_this2.isStart) return;
	      if (_this2.stream && _this2.stream.getAudioTracks().length === 0) return;
	      _this2.isStart = true;
	      var volumeDetectorV2 = _this2; // const micStream = await volumeDetectorV2.getMicStream();

	      var audioContext = volumeDetectorV2.audioContext = new AudioContext();
	      volumeDetectorV2.source = audioContext.createBufferSource(); // volumeDetectorV2.mediaStreamSource = volumeDetectorV2.audioContext.createMediaStreamSource(micStream);

	      volumeDetectorV2.analyser = audioContext.createAnalyser();
	      volumeDetectorV2.processor = audioContext.createScriptProcessor(2048, 1, 1);
	      volumeDetectorV2.analyser.smoothingTimeConstant = 0.8;
	      volumeDetectorV2.analyser.fftSize = 1024;
	      volumeDetectorV2.source.connect(audioContext.destination);
	      volumeDetectorV2.source.connect(volumeDetectorV2.analyser); // volumeDetectorV2.mediaStreamSource.connect(volumeDetectorV2.analyser);

	      volumeDetectorV2.analyser.connect(volumeDetectorV2.processor);
	      volumeDetectorV2.processor.connect(audioContext.destination);

	      volumeDetectorV2.processor.onaudioprocess = function (e) {
	        volumeDetectorV2.volumeAudioProcess(e);
	      };

	      audioContext.decodeAudioData(arrayBuffer, buffer => {
	        volumeDetectorV2.source.buffer = buffer;
	        volumeDetectorV2.source.start(0);
	        volumeDetectorV2.source.loop = true;
	      });

	      _this2.trigger(Events.Start);
	    })();
	  }

	  start() {
	    var _this3 = this;

	    return _asyncToGenerator(function* () {
	      if (_this3.isStart) return;
	      if (_this3.stream && _this3.stream.getAudioTracks().length === 0) return;
	      _this3.isStart = true;
	      var volumeDetectorV2 = _this3;
	      var micStream = yield volumeDetectorV2.getMicStream();
	      volumeDetectorV2.audioContext = new AudioContext();
	      volumeDetectorV2.mediaStreamSource = volumeDetectorV2.audioContext.createMediaStreamSource(micStream);
	      volumeDetectorV2.analyser = volumeDetectorV2.audioContext.createAnalyser();
	      volumeDetectorV2.processor = volumeDetectorV2.audioContext.createScriptProcessor(2048, 1, 1);
	      volumeDetectorV2.analyser.smoothingTimeConstant = 0.8;
	      volumeDetectorV2.analyser.fftSize = 1024;
	      volumeDetectorV2.mediaStreamSource.connect(volumeDetectorV2.analyser);
	      volumeDetectorV2.analyser.connect(volumeDetectorV2.processor);
	      volumeDetectorV2.processor.connect(volumeDetectorV2.audioContext.destination);

	      volumeDetectorV2.processor.onaudioprocess = function (e) {
	        volumeDetectorV2.volumeAudioProcess(e);
	      };

	      _this3.trigger(Events.Start);
	    })();
	  }

	  stop() {
	    if (!this.isStart) return;
	    this.isStart = false;

	    try {
	      this.mediaStreamSource.disconnect(this.analyser);
	      this.analyser.disconnect(this.processor);
	      this.processor.disconnect(this.audioContext.destination);
	      this.clearAudioContext();
	    } catch (err) {
	      console.log(err);
	    } finally {
	      if (this.source) {
	        this.source.stop();
	        delete this.source;
	      }

	      this.trigger(Events.Stop);
	    }
	  }

	}

	exports.MediaDevice = MediaDevice;
	exports.StreamManager = StreamManager;
	exports.VolumeDetector = VolumeDetector;
	exports.VolumeDetectorEvents = Events;

	return exports;

}({}));
